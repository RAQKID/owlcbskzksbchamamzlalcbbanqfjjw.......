class Client {
  constructor(apiKey, dev = false, isBrowser = typeof window !== "undefined") {
    this.#isBrowser = isBrowser;
    this.host = `http${dev ? "://localhost:8080" : "s://api.bytez.com"}/models/v2/`;
    this.headers = {
      lang: "javascript",
      Authorization: `Key ${apiKey}`,
      "content-type": "application/json"
    };
    if (isBrowser === false) {
      import('stream').then((module) => {
        this.#Readable = module.Readable ?? module.default?.Readable;
      });
      new Function('return import("undici")')().then(({ Agent }) => {
        this.#dispatcher = new Agent({
          keepAliveTimeout: this.#timeout,
          keepAliveMaxTimeout: this.#timeout,
          connectTimeout: this.#timeout,
          headersTimeout: this.#timeout,
          bodyTimeout: this.#timeout
        });
      });
    }
  }
  #Readable;
  #isBrowser;
  #dispatcher;
  #timeout = 15 * 6e4;
  host = "";
  headers = {};
  async request(path, method, body, providerKey) {
    try {
      const res = await fetch(this.host + path, {
        method,
        headers: providerKey === void 0 ? this.headers : { ...this.headers, ["provider-key"]: providerKey },
        // @ts-expect-error  dispatcher is undici-only
        dispatcher: this.#dispatcher,
        signal: AbortSignal.timeout(this.#timeout),
        body: body ? JSON.stringify(body) : void 0
      });
      if (method === "POST" && !res.ok && res.headers.get("content-type") !== "application/json") {
        const { error } = await res.json().catch(console.error);
        throw new Error(error || res.statusText);
      }
      if (res.body !== null && (body?.stream === true || body?.json === false)) {
        return this.#isBrowser ? res.body : this.#Readable.fromWeb(res.body);
      } else {
        return await res.json();
      }
    } catch (error) {
      return { error: error.message, output: null };
    }
  }
}

class Model {
  constructor(modelId, bytez, client, providerKey) {
    this.#client = client;
    this.id = modelId;
    this.#providerKey = providerKey;
    this.#ready = bytez.list.models({ modelId }).then((response) => {
      const mediaGenerators = [
        "text-to-audio",
        "text-to-image",
        "text-to-video",
        "text-to-speech"
      ];
      this.details = response?.output?.[0] ?? {};
      this.#isGeneratingMedia = mediaGenerators.includes(this.details.task);
    });
  }
  #client;
  #ready;
  #isGeneratingMedia = false;
  #providerKey;
  /** The modelId, for example `openai-community/gpt2` */
  id;
  /** Default model params */
  params;
  /** details about the model */
  details;
  async run(input, params, stream) {
    const postBody = {
      params: typeof params === "boolean" || params === void 0 ? void 0 : params
    };
    await this.#ready;
    if (params === true || stream === true) {
      if (this.#isGeneratingMedia) {
        postBody.json = false;
      } else {
        postBody.stream = true;
      }
    }
    postBody["input"] = input;
    return this.#client.request(this.id, "POST", postBody, this.#providerKey);
  }
}

class Bytez {
  constructor(apiKey, dev = false, browser) {
    this.#client = new Client(apiKey, dev, browser);
  }
  #client;
  list = {
    /** Lists available models, and provides basic information about each one, such as RAM required */
    models: (options) => this.#client.request(
      `list/models${options?.task ? `?task=${options.task}` : ""}${options?.modelId ? `?modelId=${options.modelId}` : ""}`
    ),
    /** List available tasks */
    tasks: () => this.#client.request("list/tasks")
  };
  /**
   * Get a model - allows you to run closed and open source models
   * @param modelId The modelId, for example `openai-community/gpt2`
   * @param providerKey Optional: Closed-source model provider's API key (e.g. OpenAI key)
   */
  model = (modelId, providerKey) => new Model(modelId, this, this.#client, providerKey);
}

export { Bytez as default };
